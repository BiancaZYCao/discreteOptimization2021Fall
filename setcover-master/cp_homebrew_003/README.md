cp solver for setcover problem
==================
The MIT License (MIT)

&copy; 2017 Yuri Kovalev

This CP solver can find the optimal solution on small datasets (until `sc_45_0`)

For greater datasets there is a timeout option. After timeout it stops searching and submits best found solution (with `.proven_as_optimal=False`).
In practice, the solver only takes a few minutes to get 7/10 scores for all tasks in the assignment.

Further search is not so productive and does not improve solutions significantly.


**How search performs**

* On each step we pick a set, basing on it covering and the cost:
  * Estimate significance of each item, based on how many sets can cover it (excluding ones, that we already have marked as unselected). The lesser candidates item has, the more critical item is.
  * Choose a set with maximum ratio between sum of items significance and cost of the set.

* Perform binary deep search:
  * At first, we try to select each set until reach full cover.
  * Then, we try to deselect last set and try to select following ones.
  * When all sets are exhausted, we rollback to last set, which still selected

* For pruning search, we use optimistic estimation based on "partial sets":
  * We "split" every set on count of not covered items that it can cover. It means dividing its cost by regions.
  * We choose cheapest partial set for every item. Thus, if all items prefer the same set, the sum of parts will be exactly the cost of this set.

* Propagating constraints
  * If we deselect the set and some of items can't be covered by following sets - this is infeasible state. So, we rollback to the last still selected set and try deselect it.
  * If some item can be covered by one set only, we immediatly select it.
  * If set can't cover at least one item, which not covered yet, it is conceded as useless and removed from following search.
  * I'd tried to remove redundant sets - that cover exactly the same items with cheaper ones. But it turns out to be too expensive calculation which slows down the search.


**Utils**

In addition to the solver, I added some supplementary scripts for development.

`reader.py`:

It can read dataset from given file and parse it into the structure `Task`, that more convenient than raw text.

Also, it can generate filenames with datasets of given size. This is usefull for testing solver on the set of examples with reasonable execution time.

`validator.py`:

It can prove opmtimality of given solver. It compares solution with control solution, generated by simple bruteforce solver. Of course, this feature works only on small examples.

For big examples there is function `is_valid()`, that can prove feasibility of solution.


`performance.py`:

It apply given solver to the task and print the duration in seconds.
